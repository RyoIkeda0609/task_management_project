# PARANOIA MODE DIRECTIVE

目的：
100点を取る。
未来の事故をゼロにする。

---

# Phase 1：設計の「破壊経路」封鎖

---

## 1. 層間依存を再チェック

- Presentation → Domain 直接依存していないか？
- Infrastructure → Domain の実装詳細を知っていないか？
- Application が UI 型を知らないか？

違反が1つでもあれば修正。

---

## 2. Domain 不変条件の網羅テスト

以下を必ず追加：

- 不正状態遷移
- 二重更新
- 同一ID衝突
- 空値境界
- 期限境界

Domain は絶対に壊れない層にする。

---

---

# Phase 2：将来拡張への耐性検査

---

## 1. クラウド同期を入れたら壊れる箇所は？

- ID生成戦略
- Repositoryの想定
- 同時更新

脆弱箇所があれば抽象化を追加。

---

## 2. 状態が増えたら壊れる場所は？

例：

Todo/Doing/Done に
Archived が追加されたら？

壊れるコードを列挙し、switch/ifを削減。

---

---

# Phase 3：Guardの最終封印

---

全コード検索：

- null
- ??
- fallback
- try/catch

理由を説明できないものは削除。

---

---

# Phase 4：対称性完全化

---

各画面の構造を横並びで比較。

1画面だけ特別扱いがあれば修正。

---

---

# Phase 5：テストのパラノイア化

---

テストは：

正常系 40%
異常系 40%
境界値 20%

になるよう補強。

---

---

# Phase 6：自己レビュー質問

---

このコードを3年後の自分が読んで：

- 意図が即わかるか？
- 責務が即説明できるか？
- 改修が怖くないか？

YES 以外なら修正。

---

# 完了判定

設計が壊れる未来が想像できない。

🔥 さらに具体的にやること

以下は本当に効きます：

① Domain を “閉じた世界” にする

new できる場所を制限

コンストラクタを極限まで守る

factory に寄せる

② 例外を「仕様」にする

想定外例外は禁止

失敗パターンを明文化

③ 列挙型の exhaustive check

switch で default 禁止

将来値追加でコンパイルエラーにする

④ Repository の戻り値を非nullableに統一

曖昧さゼロ。

⑤ State は immutable を絶対保証

copyWith の挙動もテスト。
