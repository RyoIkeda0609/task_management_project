# Presentation Refactor Execution Order

既存UIを安全に製品品質へ上げるための修正順

目的：
すでに仮実装しているPresentation層の責務と構造を整理する。
現時点では骨組み的な実装がされているため、その品質を高め、この後のステップで予定しているUIの改善（見た目の改善）がしやすい状態にする。

---

# 🎯 絶対ルール

順番を守る。

飛ばすと崩れる。

---

---

# 全体戦略

UI を

巨大な塊
↓
分離された構造

へ変える。

---

外側から整えるのではなく、

「思考の流れ」
から直す。

---

---

# Phase 0

## 触ってはいけない

- Domain
- UseCase
- Repository

絶対に触らない。

---

---

# Phase 1

## Page を痩せさせる

---

### やること

Page に書かれている：

- データ加工
- 条件判断
- 非同期制御

を ViewModel に移す。

---

### 完了条件

Page は

- Provider を読む
- Widget を並べる

だけになる。

---

---

# Phase 2

## build() の分解

---

### やること

長い build を

- header
- content
- action

へ分割。

---

if があるなら  
widget に逃がす。

---

### 完了条件

build を見て

構造が即分かる。

---

---

# Phase 3

## イベントの純化

---

### やること

onTap 内の処理を

全部 ViewModel へ。

---

### NG

UI 内で

- status 判定
- 所属確認

---

---

# Phase 4

## State の導入・整理

---

### やること

UI 表示専用モデルを作る。

Domain を直接使わない。

---

### 完了条件

Widget は state を描画するだけ。

---

---

# Phase 5

## Widget 抽出

---

### やること

再利用 or 可読性のために分割。

---

### 重要

ロジックは入れない。

---

---

# Phase 6

## 命名統一

---

### 確認

- 他画面と同じか？
- 予測できるか？

---

---

# Phase 7

## 仕上げ

---

ここで初めて

- 見た目
- UX
- 微調整

を行う。

---

---

# 🔥 AI 実行時の具体命令

AI は各 Phase を

1画面ずつ  
完全終了させてから  
次へ進む。

---

横断的に触らない。

---

---

# 成功判定

- 似た画面は同じ構造
- build が短い
- UI が賢くない
- ViewModel が窓口

これでOK。
