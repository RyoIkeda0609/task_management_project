# Source Code Quality Charter

Task Management Project – Official Code Standard

目的：
本プロジェクトにおける
「良いソースコード」の定義を明文化する。

すべてのコードは本規約に従う。

---

# 1. 良いコードの定義

良いコードとは：

1. 読んだ瞬間に意図が分かる
2. 責務が明確に分離されている
3. 将来の変更に強い
4. テストで守られている
5. 同じ構造が繰り返される
6. 「なぜここにあるのか」が説明できる

---

# 2. 基本原則

## 2.1 単一責任原則（SRP）

- 1クラス = 1責務
- 1メソッド = 1意図
- 「and」が説明に入るなら分割

---

## 2.2 予測可能性

読者が次を予測できる構造であること。

- 同じ役割は同じ名前
- 同じ画面構造は同じレイアウト
- 同じ処理は同じ流れ

驚きは禁止。

---

## 2.3 意図の明確化

コメントではなく命名で意図を伝える。

悪い例：

process()
handle()
update()

良い例：

markTaskAsDone()
calculateGoalProgress()
deleteMilestoneCascade()

---

## 2.4 ガードの集中化

nullチェック・境界値チェックは
最も内側の層に集中させる。

UI・ViewModelでの二重防御は禁止。

---

## 2.5 不変性の尊重

- Entity / ValueObject は可能な限り immutable
- State は必ず immutable
- copyWith は明示的

---

# 3. レイヤー別品質基準

---

# 3.1 Domain 層

## 定義

ビジネスルールの純粋領域。

## 禁止

- UI語彙（display, label, formatted）
- null許容設計
- 外部依存

## 必須

- 不変条件の保証
- 不正状態遷移の禁止
- exhaustive switch

## テスト

- 正常系
- 異常系
- 境界値
- 不正遷移

---

# 3.2 Application 層

## 定義

UseCase orchestration 層。

## 禁止

- ビジネスロジック
- UI型の利用
- 表示整形

## 許可

- Repository 呼び出し
- Domain 呼び出し
- 最低限の結果変換

---

# 3.3 Infrastructure 層

## 定義

永続化・外部I/O。

## 禁止

- null返却
- 例外握りつぶし
- Domainロジックの実装

## 必須

- 失敗は明示的例外
- mapping責務の明確化

---

# 3.4 Presentation 層

## 定義

描画のみ。

## 原則

UIは dumb。

## 禁止

- ビジネス判断
- null fallback
- 状態の再解釈

## 構造テンプレ

Scaffold
├ HeaderWidget
├ ContentWidget
└ ActionWidget

完全対称。

---

# 4. クリーンコード規約

---

## 4.1 メソッド長

- 20行以内を原則
- 超える場合は分割

---

## 4.2 ネスト深度

- 3階層以内
- 4以上は禁止

---

## 4.3 if の扱い

- if が2個以上ある場合は再設計を検討
- UIでの条件ロジックは stateへ移動

---

## 4.4 命名規約

- 名詞は Entity
- 動詞は UseCase
- ～State は immutable data
- ～Widget は描画専用

---

## 4.5 コメント

コメントは「なぜ」だけを書く。
「何を」はコードで表現。

---

# 5. 共通化の基準

---

## 共通化すべき条件

- 3回以上出現
- 意図が同じ
- 変更される可能性がある

---

## 共通化してはいけない

- 似ているが意味が違う
- 将来分岐する可能性が高い

---

# 6. テスト品質基準

---

## 6.1 テストの役割

設計を守るためのもの。

---

## 6.2 カバレッジ目標

- Domain：95%以上
- Application：90%以上
- Infrastructure：80%以上
- Presentation：必要最小限

---

## 6.3 テスト分類

- 正常系
- 異常系
- 境界値
- 回帰防止

---

# 7. 保守性の定義

保守しやすいコードとは：

- 新機能追加時に既存コードをほぼ触らない
- 変更箇所が予測できる
- テストが即失敗を教える

---

# 8. 未来耐性チェック

以下に YES と答えられること：

- 状態が増えても壊れないか？
- Repository が別実装になっても壊れないか？
- 3年後の自分が読めるか？

---

# 9. 最終判定基準

レビュー時に：

- 違和感がない
- 責務が説明できる
- 書き方が揃っている
- 守るべき文化が明文化されている

これを満たすものを「良いコード」と定義する。

---

# 結論

本プロジェクトにおいて

良いコードとは：

「壊れにくく、読みやすく、意図が明確で、将来を裏切らないコード」

である。

すべての変更は、この規約に照らして評価される。
