# improvement_playbook.md

本ドキュメントは、レビュー結果（review_score.md）を受けて

- 今どこが問題なのか
- なぜそれが発生するのか
- 放置すると何が起きるのか
- どう直すのか
- どう書けば良いのか（例）

を AI / 開発者がそのまま実行できる粒度でまとめた **改善実行手引き** である。

感想は禁止。  
必ず「修正できる指示」にする。

---

# 全体方針

今のコードは悪くない。
しかし次の成長段階では、

**小さな責務漏れが将来の崩壊原因になる。**

よって修正対象は：

- 小さい違反
- ついやりたくなる便利処理
- 一見正しそうな親切設計

である。

---

# 問題1：Presentation がまだ少し判断している

## 症状

Provider / Controller / UI で

- 分岐
- 再計算
- 成功後の業務的な次動作

が存在する。

## なぜ起きる？

UI を作ると「ついここでやりたくなる」から。
最も自然に腐る場所。

## 放置すると？

機能追加のたびにここが太る。
最終的に UseCase が空洞化する。

## 改善原則

Presentation は：

- 呼ぶ
- 受け取る
- 表示する

だけ。

---

## ❌ 悪い例

```dart
if (task.isDone) {
  ref.read(goalProvider.notifier).refresh();
}
```

---

## ✅ 良い例

```dart
await completeTaskUseCase.execute(taskId);
```

再取得や影響計算は別の仕組みで行う。
Provider は業務判断を持たない。

---

# 問題2：UseCase が少し賢くなり始めている

## 症状

- エラー文言を作る
- 成功条件をUIに合わせる
- 特定画面前提の戻り値

## なぜ起きる？

呼び出し元の便利のため。

## 放置すると？

UI変更が UseCase を破壊する。

---

## 改善原則

UseCase は CLI から呼ばれても成立する形に保つ。

---

## ❌ 悪い例

```dart
return "ゴールを作成しました";
```

---

## ✅ 良い例

```dart
return goalId;
```

文言は Presentation の責務。

---

# 問題3：Repository が賢くなる誘惑

## 症状

- 取得時に並び替える
- 不足値を補完
- progress を再計算

## なぜ起きる？

「ここでやると楽」に見えるから。

## 放置すると？

Domain の存在理由が消える。

---

## 改善原則

Repository = ストレージの窓口  
意味を与えない。

---

## ❌ 悪い例

```dart
tasks.sort(...);
```

---

## ✅ 良い例

```dart
return storedTasks;
```

順序が必要なら Application 側。

---

# 問題4：テストが優しすぎる

## 症状

成功確認が多く、
破壊検知が弱い。

## なぜ起きる？

通るテストは気持ちいいから。

## 放置すると？

リファクタで思想が死ぬ。

---

## 改善原則

仕様違反を積極的に落としに行く。

---

## 必須追加例

- Goal 直下に Task 作成 → 失敗
- 他 Milestone へ移動 → 失敗
- progress 手動変更 → 不可

---

# 問題5：DTO と Entity の境界の揺れ

## 症状

UI 用データを Entity に求め始める。

## 放置すると？

API / DB 導入時に爆発。

---

## 改善原則

変換は必ず Application または Presentation。

---

# まず何から直す？（即効順）

1. Provider から if / switch を減らす
2. UseCase の戻り値を純化
3. Repository から処理を抜く
4. 失敗系テスト追加

---

# 完了判定

- Provider が薄く読める
- UseCase が短い
- Repository が何も知らない
- テストが壊すと怒る

これが揃えば、
拡張はかなり安全になる。
